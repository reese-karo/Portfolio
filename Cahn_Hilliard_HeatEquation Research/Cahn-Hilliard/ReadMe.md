### About

This code simulates the Cahn-Hilliard (CH) equation with variable mobility. 

### Overview

#### Settings and notation

| symbol | property | meaning |
|:----:|:--- |:--:|
|$\Omega$| $=(0, L)^2$, ($L>0$) | spatial domain |
|$L$ | $>0$ | length of square domain $\Omega$|
|$\varepsilon$ | $>0$ | Thickness of phase interfaces|
|$M$ |$:\mathbb{R}\to\mathbb{R}$ | Mobility |
|$T$ | $\in\mathbb{R}$| final time of time evolution|
|$\Psi(x)$| $=\frac 1 4 (1-x^2)^2$ | Double-well potential|
|$\psi(x)$| $=\Psi'(x)$ <br> $=x(x-1)(x+1)$ | Derivative of the double-well potential|
|$K$ | $\in\mathbb{N}$| Number of time steps|
|$N$ | $\in\mathbb{N}$| Resolution of spatial discretization |
|$u$ | $:\Omega\to\mathbb{R}$ or <br> $:\mathbb{N}_N^2 \to \mathbb{R}$ | (Abuse of notation) <br> phase function (either continuous or discrete)
|$u^k$ | $\approx u(kT/K)$ | k-th time iterate|

#### Cahn-Hilliard (CH) equation 

$$ \begin{split}
u_t = \nabla \cdot (M(u)\nabla w),
\\
w = -\varepsilon^2 \Delta u + \psi(u),
  \end{split}
$$

supplemented with periodic boundary conditions on a square domain $\Omega$,  where $w$ is called *chemical potential*.

#### Discretization

For computation purposes, we use implicite Euler scheme in time. In doing so, we use the current phase state for the mobility. Then, we obtain

$$ \begin{split}
\frac{u^{k+1}-u^k}{T/K} = \nabla \cdot (M(u^k)\nabla w^{k+1}),
\\
w^{k+1} = -\varepsilon^2 \Delta u^{k+1} + \psi(u^{k+1}).
  \end{split}
$$

Eliminating the chemical potential, we obtain

$$
\frac{u^{k+1}-u^k}{T/K} = \nabla \cdot (M(u^k)\nabla [-\varepsilon^2 \Delta u^{k+1} + \psi(u^{k+1})])
.
$$


### Usage

#### Simulate CH equation

1. Open `main.py`
2. Tune parameters.
   1. `rep_par` (reporting paramter)
      - `save_data`: If `True`, save the result as a file.
      - `data_to_save`: (shouldn't be modified unless there is a clear reason.) Python variables that are saved in a file.
      - `filename`: If `auto.pkl`, a new file is created with the name generated by time stamp. Other names (e.g., `name.pkl`) overwrites the current file with the same name.
      - `schedule_scheme`: Only `periodic` is supported for now.
      - `Nsaves`: The number of saves along time evolution. For example, if the discrete time grid consists of 100 grid points (exculding the inital time) and `Nsaves = 20`, the data listed in `data_to_save` are saved every 5 time marching 
    2. `pde_par` (PDE-related parameters)
      -`LL`: (1.0 recommended if there is no particular reason.) The length of (spatial) square domain.
      -`TT`: (Something not too large is recommended, e.g., 0.01, 0.1, etc. at least to begin with.) Final time of evolution.
      - `eps`: (1e-2 recommended if there is no particular reason) epsilon (thickness of interfaces).
      - `pde_par['fn_mob']`: 
        - (**Key parameter**) Mobility function. 
        - Use this for constructing dictionary matrix of sparse learning.
        - It must be a string for a Python script that implement a function.(e.g. "lambda xx: 1." for a constant mobility.)
        - This weird syntax is a work around because pickle package cannot store lambda functions, but it can store strings.
        - Reasonable options for mobility functions: use functions whose output is not too big or not too small (somewhere between 0.1 and 3) when the domain is $-2 \le x \le 2$
    1. `ic_par` (Initial condition parameters)
       - Stick to the current setting of 'random fluctuation' type.
        ```
        ic_par = {'type': "random fluctuation", # initial condition (IC) type 
          'avg_height': 0.3, 
          'fluc': 0.1,
          'seed': 1234 # specify random seed if implementation needs to be done with the same IC.
          } # IC parameter
        ``` 
      - If there is no hope for an interesting exploration with this settings, (a) change `fluc` to a smaller value. If that does not work, (b) contack Jea-Hyun.
    1. `num_par` (numerical parameters) 
       - `NN`: (2**6 recommended if there is no particular reason) Resolution of spatial descritization.
      - `KK`: number of time steps == (#of time grid pts) - 1
            - This should be determined based on the final time `TT`. Determine `KK` so that the time step size `TT/KK` is somewhere around 0.001. Time step size 0.0001 or 0.01 is maybe worth trying, but too big or too small numbers will likely lead to undesirable results.
      - `time_dis`: (Only `imEuler` is supported for now) Time discretization scheme.
      - `TOL_in`: (1e-5 recommended) inner loop tolerance of PPGD solver for a single time marching
      - `TOL_out`: (1e-4 recommended) outer loop tolerance of PPGD solver for a single time marching
      - `beta`: (0.5 recommended; Values between 0.2 - 1.0 resulted in reasonably good output from the trial and error.) step size of the outer loop of PPGD solver for a single time marching.
3. Run `main.py` with Python 3.8 or higher with PyTorch, Matplotlib, 

#### Open saved data

1. Open `CHHelper.ipynb`.
   1. To see the plots related to the numerical simulation, run the first code cell:
      ```
      import CHReporter

      #--- type the target file name and run this block
      filename = 'target_file_name.pkl'
      CHReporter.report_saved_data(filename)
      ``` 
  1. To load the numerical data of a saved simulation, run the second code cell:
    ```
    from CommonTools.fileio_tools import save, open_pickled_file

    #--- type the target file name and run this block
    filename = "OUT/ch_sancheck1H-1resbeta0p2.pkl"
    file_loaded = open_pickled_file(filename)

    ch_log = file_loaded['ch_log'] 
    ch_eqn_data = file_loaded['ch_eqn_data'] 
    ch_num_sol = file_loaded['ch_num_sol'] 
    rep_par = file_loaded['rep_par']   
    ```
  1. For an example of what you can do with loaded data, eyeball the rest of `CHHelper.ipynb`.

### Structure

#### Flow of typical simulations
1. `CHPoser.py` poses the CH equation by generating initial condition, and other data (PDE parameters, numerical settings, grid domain, etc.)
2. `CHSolver.py` solves the CH equation.
3. `CHReporter.py` reports, plots, saves the solution and computation log. 

#### Main data

**Data related to numerical solution**

- `ch_num_sol` stores all numerical data of CH evolution.
  - `ch_num_sol[kk]`: `kk`-th **saved** time iterate. (e.g., if `KK == 100` and 20 still shots are saved, `ch_num_sol[100]` does not exist, but `ch_num_sol[20]` corresponds to the state at the final time.)
- `ch_log` stores all numerical data related to performance, residuals, etc. during the whole time marching. 
  - If there is no weird issue, this is not something you need to look at first.
  - If `ch_log['res_out']` is too big, say 0.01, then this means the PPGD solver was not able solve the CH equation very accurately. In particular, it is likely be related to outer loop: nonlinearity.
  - If `ch_log['res_in']` is too big, say 0.001, then this means the PPGD solver was not able solve the CH equation very accurately.In particular, it is likely be related to inner loop: stringent mobility.

**Data related to CH eqn settings**

- `ch_eqn_data` stores all necessary parameters (i.e., what is contained in `pde_par` and `num_par`) and array data (e.g., initial condition, grid domain, fcm eigenvalues, etc.) regarding CH equation. 
- (minor) `pde_par` stores concise parameters for the CH equation. 
- (minor) `num_par` stores concise parameters for the numerical settings.
- `rep_par` stores settings related to reporting. However, `Nsaves` also affects how we access numerical solution when loaded from a file. (e.g., if `KK == 100` and 20 still shots are saved, `ch_num_sol[100]` does not exist, but `ch_num_sol[20]` corresponds to the state at the final time.)

### Comments convention

To avoid confusion bewteen commented-out code lines and real comments, I used the following convention.

| convention example | meaning |
|:----:|:----:|
|`#=== setting parameters`| level 1 comment (top level of the main block of code) |
|`#-== numerical parameters` | level 2 comment (comments on subtasks of level 1) |
|`#--= use dict` | level 3 comment (comments on subtasks of level 2) |
|`#--- comment`, `# -- comment`, `#  - comment` | level 4, 5, 6 resp. in a similar manner|
|`#*** comment`| superlevel comment; higher than level 1 |

